
(--
 Meme prelude.
 --)

|-- Pull in functions defined in native code.

let ast|assert = __native__("ast|assert")
let ast|structEq = __native__("ast|structEq")
let ast|lambda = __native__("ast|lambda")
let ast|isIdent = __native__("ast|isIdent")
let ast|isList = __native__("ast|isList")
let ast|toList = __native__("ast|toList")
let ast|quasiquote = __native__("ast|quasiquote")
let ast|qqSub = __native__("ast|qqSub")

(++
 `let'` allows you to bind the value of one or more expressions to names
 and then use those names in another expression.

 This allows you to use the result of an expression many times whilst only 
 evaluating it once, or simplifying complex expressions.

 Unlike `let`, expressions are bound in lexical order.

 For example::

    let'(
        [r, 4.0],
        [c, pi*r**2],
        printLn("Circumference of a circle with 4m radius is ",c,"m")
    )

 Note that bindings are available for use immediately after their definition, but not before.  For example, assuming no
 local bindings for `a`::

    let'([a, 1], [b, 2*a], 3*b) |-- Result: 6
    let'([b, 2*a], [a, 1], 3*b) |-- Error: a is not defined.

 .. syntax::
    let'([ident, value]..., expr)

 .. args:: ident

    Identifier to which `value` should be bound.

 .. args:: value

    Expression whose value should be bound to `ident`.

 .. args:: expr

    Expression to evaluate with the given bindings.
++)
let macro let'(ls...) = (\l, ls:
    if( ls = [],
        l,
        do(
            (-- check that l is of the form [ident, *] --)
            ast|assert(l, ast|isList(l), "expected [ident, expr], got a $$" (.format.) [ast|typeOf(l)]),
        (\l':
            (\ll: ast|assert(l, ll = 2, "expected [ident, expr], got a list with $$ elements" (.format.) [ll]))
                (l' (.length)),
            (\id: ast|assert(id, ast|isIdent(id), "expected identifier, got a $$" (.format.) [ast|typeOf(id)]))
                (l' (.head)),

            (-- Rewrite let'([ident, expr], ls...) --> (\ident: ls...)(expr) --)
        (\ident, expr:
            #~"((\#~$(ident): let'(#~$(ls)...))(#~$(expr)))
        )(head(l'), (tail.head)(l'))
        )(ast|toList(l))
        )
    )
)(
    (-- l --)   head(ls),
    (-- ls --)  tail(ls)
)

let macro case(a, c, cs...) = let'(
    (--
        This macro basically rewrites::

            case(a, [t, e], cs...)

        into::

            if(a = t, e, case(a, cs...))

        An exception is made when ``t`` is ``else`` and ``cs`` is empty; in
        that case, it is rewritten simply as::

            e
     --)
    [_,     ast|assert(c, ast|isList(c),
                "expected [test, expr] for case, got a $$"
                    (.format.) [ast|typeOf(c)])],
    [c',    ast|toList(c)],
    [cl,    ast|length(c')],
    [_,     ast|assert(c, cl = 2,
                "expected [test, expr] for case, got $$ element$$"
                    (.format.) [cl, if(cl=1,"","s")])],
    |-- test
    [t,     head(c')],
    |-- expr
    [e,     (head.tail)(c')],
    |-- unique identifier
    [id,    ast|uniqueIdent~()],
    |-- use test - false if there's no need to branch
    [ut,    not (length(cs) = 1 and t (.ast|structEq.) #~"(else))],
    |-- test ast
    [ta,    #~"(#~$(id) = #~$(t))],
    |-- tail expr
    [tail,  if(length(cs) > 1,
                #~"(case(#~$(id), #~$(cs)...)),
                #~"(nil))],

    #~"(#~$(ast|lambda([ast|identName(id)],
        if(ut,
            #~"(if(#~$(ta), #~$(e), #~$(tail))),
            #~$(e))))
        (#~$(a))
    )
)

let macro cond(c, cs...) = let'(
    (--
        The goal here is to rewrite::

            cond([t, e], cs...)

        into::

            if(t, e, cond(cs...))

        An exception is made when ``t`` is ``else`` and ``cs`` is empty.  In
        that case, it is rewritten to::

            e
     --)
    [_,     ast|assert(c, ast|isList(c),
                "expected [test, expr] for cond, got a $$"
                    (.format.) [ast|typeOf(c)])],
    [c',    ast|toList(c)],
    [cl,    length(c')],
    [_,     ast|assert(c, cl = 2,
                "expected [test, expr] for cond, got $$ element$$"
                    (.format.) [cl, if(cl=1,"","s")])],
    |-- test
    [t,     head(c')],
    |-- expr
    [e,     (head.tail)(c')],
    |-- use test - false if this is the last rule and the test is "else"
    [ut,    not (length(cs) = 1 and t (.ast|structEq.) #~"(else))],

    |-- tail expr
    [tail,  if(length(cs) > 1,
                #~"(cond(#~$(cs)...)),
                #~"(nil))],

    if(not ut,
        e,
        #~"(if(#~$(t), #~$(e), cond(#~$(cs)...))))
)

