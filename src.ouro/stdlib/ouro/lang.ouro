(++

    This module defines all language-defined functions, macros and constants.
    
 ++)

|--
|-- Builtins
|--

export let branch = __builtin__("ouro.branch")
export let fail = __builtin__("ouro.fail")
export let $".dump" = __builtin__("ouro..dump")

|--
|-- Functions defined in terms of builtins.
|--

export let macro assert(expr) = (
    #"{ #${if} { #${expr},
                 nil,
                 #${fail}(#${"Assertion failed: $*" (.format.) [expr]}) } }
)

export let astOf(v) = #"{#${v}}

export let macro do(expr, exprs...) = (
    if { exprs = [],
         expr,
         #"{ (\$"--ignore".#${do(exprs...)})(#${expr}) } }
)

export let filter(f, vs) = (
    if {
        vs = [],
        [],
        let {
            [v, head(vs)],
            [vs', tail(vs)],

            if { f(v),
                 v :: filter(f, vs'),
                 filter(f, vs') }
        }
    }
)

export let format = __builtin__("ouro.format")

export let macro if(l, expr_t, expr_f) = (
    #"{ #${branch}( #${l}, \.#${expr_t}, \.#${expr_f} ) }
)

export let head(l) = (
    let {
        [head', \l', l's... . l'],

        head'(l...)
    }
)

export let lookup = __builtin__("ouro.lookup")

export let map(f, vs) = (
    if {
        vs = [],
        [],
        let {
            [v, head(vs)],
            [vs', tail(vs)],

            f(v) :: map(f,vs')
        }
    }
)

export let module = __builtin__("ouro.module")

export let reduce(f, vs) = (
    let {
        [v, head(vs)],
        [vs', tail(vs)],

        if {
            vs' = [],
            v,
            f(v, reduce(f, vs'))
        }
    }    
)

export let tail(l) = (
    let {
        [tail', \l',l's... . l's],
          tail'(l...)
    }
)


(--
    Builtins that use other modules.

    IMPORTANT: Do not, under *any* circumstances, use a mass import within
    this module.  Mass imports can only be resolved once one of the modules
    has been completely compiled.  This would be impossible here since every
    module mass imports this one.
--)

import "/ouro/ast" : isListExpr?, listExprElems, isVariableExpr?, variableIdent, LambdaExpr|new

export let macro let'(b, bs..., expr) =
    do {
        assert { b (.isListExpr?) },
    let {
        [b', listExprElems(b)],
    let {
        [b0, b' (.head)],
        [b1, b' (.(tail(.)head))],
        [bt, b' (.(tail(.)tail))],
    do {
        assert { b0 (.isVariableExpr?) },
        assert { bt = [] },
    let {
        [bi, b0 (.variableIdent)],
    let {
        [se, if {
                bs = [],
                expr,
                let'(bs..., expr) }],
    let {
        [le, LambdaExpr|new(nil, false, [bi], se)],

        #"{ (#${le})(#${b1}) }
    }
    }
    }
    }
    }
    }
    }

